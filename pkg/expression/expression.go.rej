@@ -86,6 +86,9 @@
 
 	// VecEvalJSON evaluates this expression in a vectorized manner.
 	VecEvalJSON(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
+
+	// VecEvalBool evaluates this expression in a vectorized manner.
+	VecEvalVectorFloat32(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error
 }
 
 // ReverseExpr contains all resersed evaluation methods.
@@ -567,10 +587,12 @@
 			err = expr.VecEvalString(ctx, input, result)
 		case types.ETJson:
 			err = expr.VecEvalJSON(ctx, input, result)
+		case types.ETVectorFloat32:
+			err = expr.VecEvalVectorFloat32(ctx, input, result)
 		case types.ETDecimal:
 			err = expr.VecEvalDecimal(ctx, input, result)
 		default:
-			err = fmt.Errorf("invalid eval type %v", expr.GetType().EvalType())
+			err = errors.Errorf("unsupported type %s during evaluation", evalType)
 		}
 	} else {
 		ind, n := 0, input.NumRows()
@@ -758,7 +793,7 @@
 				ind++
 			}
 		default:
-			err = fmt.Errorf("invalid eval type %v", expr.GetType().EvalType())
+			err = errors.Errorf("unsupported type %s during evaluation", expr.GetType().EvalType())
 		}
 	}
 	return
@@ -1279,6 +1314,9 @@
 			return function.GetArgs()[0].GetType().GetType() != mysql.TypeYear
 		case tipb.ScalarFuncSig_CastTimeAsDuration:
 			return retType.GetType() == mysql.TypeDuration
+		case tipb.ScalarFuncSig_CastVectorFloat32AsString,
+			tipb.ScalarFuncSig_CastVectorFloat32AsVectorFloat32:
+			return true
 		}
 	case ast.DateAdd, ast.AddDate:
 		switch function.Function.PbCode() {
@@ -1469,6 +1507,10 @@
 }
 
 func canExprPushDown(expr Expression, pc PbConverter, storeType kv.StoreType, canEnumPush bool) bool {
+	if expr.GetType().GetType() == mysql.TypeTiDBVectorFloat32 {
+		// For both TiKV and TiFlash, currently Vector cannot be pushed.
+		return false
+	}
 	if storeType == kv.TiFlash {
 		switch expr.GetType().GetType() {
 		case mysql.TypeEnum, mysql.TypeBit, mysql.TypeSet, mysql.TypeGeometry, mysql.TypeUnspecified:
